<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SMPLJAM</title>

<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0d0d0d; --panel: #161616; --border: #2a2a2a;
    --accent: #e8ff3a; --red: #ff3a3a; --dim: #444; --text: #f0f0f0; --sub: #666;
  }
  body {
    background: var(--bg); color: var(--text); font-family: 'Courier New', Courier, monospace;
    min-height: 100vh; display: flex; flex-direction: column;
    align-items: center; justify-content: center; padding: 24px; user-select: none;
  }
  header { text-align: center; margin-bottom: 36px; }
  h1 { font-family: Impact, 'Arial Black', sans-serif; font-size: 72px; letter-spacing: 8px; color: var(--accent); line-height: 1; }
  .tagline { font-size: 10px; color: var(--sub); letter-spacing: 4px; text-transform: uppercase; margin-top: 4px; }

  .transport {
    display: flex; align-items: center; gap: 16px; margin-bottom: 32px;
    background: var(--panel); border: 1px solid var(--border); padding: 14px 24px; border-radius: 4px;
    flex-wrap: wrap; justify-content: center;
  }
  .transport label { font-size: 10px; color: var(--sub); letter-spacing: 2px; }
  .bpm-display { font-family: Impact, 'Arial Black', sans-serif; font-size: 36px; color: var(--accent); width: 80px; text-align: center; }
  .bpm-controls { display: flex; flex-direction: column; gap: 4px; }
  .bpm-btn {
    background: none; border: 1px solid var(--border); color: var(--text);
    font-family: 'Courier New', Courier, monospace; font-size: 10px; padding: 2px 8px; cursor: pointer; transition: all 0.1s;
  }
  .bpm-btn:hover { border-color: var(--accent); color: var(--accent); }
  .divider { width: 1px; height: 40px; background: var(--border); flex-shrink: 0; }
  #play-btn {
    background: none; border: 2px solid var(--accent); color: var(--accent);
    font-family: Impact, 'Arial Black', sans-serif; font-size: 18px; letter-spacing: 3px;
    padding: 8px 20px; cursor: pointer; transition: all 0.15s; border-radius: 2px;
  }
  #play-btn:hover, #play-btn.playing { background: var(--accent); color: var(--bg); }
  #metro-btn {
    background: none; border: 1px solid var(--accent); color: var(--accent);
    font-family: 'Courier New', Courier, monospace; font-size: 10px; letter-spacing: 2px;
    padding: 6px 12px; cursor: pointer; transition: all 0.15s; border-radius: 2px; text-transform: uppercase;
  }
  #metro-btn.muted { border-color: var(--border); color: var(--sub); text-decoration: line-through; }
  #metro-btn:hover { border-color: var(--text); color: var(--text); }
  .beat-indicator { display: flex; gap: 6px; align-items: center; }
  .beat-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--border); transition: background 0.05s; }
  .beat-dot.active { background: var(--accent); }

  .pads-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; width: 100%; max-width: 560px; }
  .pad {
    background: var(--panel); border: 2px solid var(--border); border-radius: 6px;
    padding: 20px; display: flex; flex-direction: column; gap: 12px;
    position: relative; overflow: hidden; transition: border-color 0.15s; min-height: 200px;
  }
  .pad::before {
    content: ''; position: absolute; inset: 0; background: var(--accent);
    opacity: 0; transition: opacity 0.08s; pointer-events: none;
  }
  .pad.flashing::before { opacity: 0.06; }
  .pad.flash-accent::before { opacity: 0.14; }
  .pad.has-sample { border-color: var(--dim); }
  .pad.recording { border-color: var(--red) !important; animation: pulse-border 0.5s infinite alternate; }
  @keyframes pulse-border {
    from { box-shadow: 0 0 0 0 rgba(255,58,58,0); }
    to   { box-shadow: 0 0 12px 3px rgba(255,58,58,0.35); }
  }
  .pad-header { display: flex; justify-content: space-between; align-items: center; }
  .pad-label { font-family: Impact, 'Arial Black', sans-serif; font-size: 22px; letter-spacing: 2px; color: var(--sub); }
  .pad.has-sample .pad-label { color: var(--text); }
  .pad-status { font-size: 9px; letter-spacing: 2px; color: var(--sub); text-transform: uppercase; }
  .pad.recording .pad-status { color: var(--red); }
  .pad.has-sample .pad-status { color: var(--accent); }
  .waveform-canvas { width: 100%; height: 44px; display: block; }

  .pad-row-select { display: flex; align-items: center; gap: 8px; }
  .row-select-label { font-size: 9px; color: var(--sub); letter-spacing: 2px; white-space: nowrap; flex-shrink: 0; }
  .row-select {
    flex: 1; background: var(--bg); border: 1px solid var(--border); color: var(--sub);
    font-family: 'Courier New', Courier, monospace; font-size: 9px; padding: 4px 6px;
    border-radius: 2px; cursor: pointer; appearance: none; text-transform: uppercase;
  }
  .row-select:focus { outline: none; border-color: var(--accent); color: var(--text); }
  .pad.has-sample .row-select { color: var(--text); border-color: var(--dim); }

  .pad-actions { display: flex; gap: 8px; }
  .btn-rec, .btn-play-pad, .btn-clear {
    flex: 1; font-family: 'Courier New', Courier, monospace; font-size: 10px; letter-spacing: 1px;
    padding: 8px 4px; border-radius: 2px; cursor: pointer; border: 1px solid;
    transition: all 0.12s; text-transform: uppercase; background: none;
  }
  .btn-rec { border-color: var(--red); color: var(--red); }
  .btn-rec:hover { background: var(--red); color: #fff; }
  .btn-play-pad { border-color: var(--accent); color: var(--accent); }
  .btn-play-pad:hover { background: var(--accent); color: var(--bg); }
  .btn-play-pad:disabled { border-color: var(--border); color: var(--border); cursor: default; }
  .btn-clear { border-color: var(--border); color: var(--sub); }
  .btn-clear:hover { border-color: #888; color: var(--text); }
  .btn-clear:disabled { opacity: 0.3; cursor: default; }

  .status-bar { margin-top: 20px; font-size: 10px; color: var(--sub); letter-spacing: 2px; text-align: center; min-height: 16px; }

  /* Groove panel */
  .groove-panel {
    width: 100%; max-width: 560px; margin-top: 16px;
    background: var(--panel); border: 1px solid var(--border); border-radius: 4px; overflow: hidden;
  }
  .groove-header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 16px; cursor: pointer;
  }
  .groove-panel.open .groove-header { border-bottom: 1px solid var(--border); }
  .groove-header-title { font-family: Impact, 'Arial Black', sans-serif; font-size: 16px; letter-spacing: 3px; color: var(--sub); }
  .groove-header:hover .groove-header-title { color: var(--text); }
  .groove-chevron { font-size: 10px; color: var(--sub); transition: transform 0.2s; }
  .groove-panel.open .groove-chevron { transform: rotate(180deg); }
  .groove-body { display: none; padding: 14px 16px; }
  .groove-panel.open .groove-body { display: block; }
  .groove-top-row { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
  .groove-select {
    flex: 1; min-width: 150px; background: var(--bg); border: 1px solid var(--border); color: var(--text);
    font-family: 'Courier New', Courier, monospace; font-size: 10px; padding: 6px 10px;
    cursor: pointer; border-radius: 2px;
  }
  .groove-select:focus { outline: none; border-color: var(--accent); }
  .groove-desc { font-size: 9px; color: var(--sub); letter-spacing: 1px; margin-bottom: 10px; line-height: 1.6; }
  .groove-beat-labels { display: flex; margin-left: 42px; margin-bottom: 3px; }
  .groove-beat-label { flex: 1; font-size: 8px; color: var(--dim); text-align: center; font-family: 'Courier New', Courier, monospace; }
  .groove-grid { display: flex; flex-direction: column; gap: 5px; }
  .groove-row-el { display: flex; align-items: center; gap: 6px; }
  .groove-row-label { font-size: 9px; color: var(--sub); letter-spacing: 1px; width: 36px; text-transform: uppercase; flex-shrink: 0; }
  .groove-steps { display: flex; gap: 2px; flex: 1; }
  .groove-step {
    flex: 1; height: 18px; border-radius: 2px; background: var(--border); transition: background 0.08s, opacity 0.08s;
  }
  .groove-step.beat-gap { margin-left: 4px; }
  .groove-step.on    { background: var(--accent); opacity: 0.45; }
  .groove-step.accent { background: var(--accent); opacity: 1; }
  .groove-step.now   { outline: 2px solid rgba(255,255,255,0.5); }
  .groove-legend { display: flex; gap: 16px; margin-top: 10px; }
  .legend-item { display: flex; align-items: center; gap: 5px; font-size: 9px; color: var(--sub); }
  .legend-swatch { width: 12px; height: 12px; border-radius: 1px; }
</style>
</head>
<body>

<header>
  <h1>SMPLJAM</h1>
  <div class="tagline">mic sampler &middot; groove engine &middot; live loop</div>
</header>

<div class="transport">
  <label>BPM</label>
  <div class="bpm-display" id="bpm-display">120</div>
  <div class="bpm-controls">
    <button class="bpm-btn" id="bpm-up">&#9650;</button>
    <button class="bpm-btn" id="bpm-down">&#9660;</button>
  </div>
  <div class="divider"></div>
  <button id="play-btn">&#9654; PLAY</button>
  <div class="divider"></div>
  <button id="metro-btn">CLICK</button>
  <div class="divider"></div>
  <div class="beat-indicator">
    <div class="beat-dot" id="dot-0"></div>
    <div class="beat-dot" id="dot-1"></div>
    <div class="beat-dot" id="dot-2"></div>
    <div class="beat-dot" id="dot-3"></div>
  </div>
</div>

<div class="pads-grid" id="pads-grid"></div>

<div class="groove-panel" id="groove-panel">
  <div class="groove-header" id="groove-header">
    <span class="groove-header-title">GROOVE GUIDE</span>
    <span class="groove-chevron">&#9660;</span>
  </div>
  <div class="groove-body">
    <div class="groove-top-row">
      <select class="groove-select" id="groove-select"></select>
    </div>
    <div class="groove-desc" id="groove-desc"></div>
    <div class="groove-beat-labels" id="groove-beat-labels"></div>
    <div class="groove-grid" id="groove-grid"></div>
    <div class="groove-legend">
      <div class="legend-item"><div class="legend-swatch" style="background:var(--accent);opacity:1"></div>accent (100%)</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--accent);opacity:0.45"></div>hit (45%)</div>
      <div class="legend-item"><div class="legend-swatch" style="background:var(--border)"></div>silent</div>
    </div>
  </div>
</div>

<div class="status-bar" id="status-bar">press REC on a pad &mdash; records until your sound ends</div>

<script>
var NUM_PADS = 4;
var PAD_NAMES = ['PAD 1','PAD 2','PAD 3','PAD 4'];
var PAD_KEYS  = ['Q','W','A','S'];
var PAD_ROW_DEFAULTS = ['kick','snare','hihat','kick'];

// Velocity per groove value: 0=silent, 1=soft hit, 2=full accent
var VELOCITY = [0, 0.42, 1.0];

var bpm = 120;
var isPlaying = false;
var currentStep = -1;
var beatInterval = null;
var audioCtx = null;
var micStream = null;
var activeRecordingPad = null;
var metroMuted = false;
var metroScheduler = null;
var metroNextTime = 0;
var metroBeat = 0;
var metroGain = null;

var pads = [];
for (var pi = 0; pi < NUM_PADS; pi++) {
  pads.push({
    index: pi,
    buffer: null,
    isRecording: false,
    mediaRecorder: null,
    chunks: [],
    mimeType: null,
    analyser: null,
    analyserSource: null,
    liveAnimFrame: null,
    vadInterval: null,
    grooveRow: PAD_ROW_DEFAULTS[pi]
  });
}

var grid = document.getElementById('pads-grid');
var statusBar = document.getElementById('status-bar');

// ── Build pad UI ──────────────────────────────────────────────────────────────
function buildUI() {
  for (var i = 0; i < NUM_PADS; i++) {
    (function(idx) {
      var el = document.createElement('div');
      el.className = 'pad';
      el.id = 'pad-' + idx;
      el.innerHTML =
        '<div class="pad-header">' +
          '<div class="pad-label">' + PAD_NAMES[idx] + '</div>' +
          '<div class="pad-status" id="pad-status-' + idx + '">empty</div>' +
        '</div>' +
        '<canvas class="waveform-canvas" id="wave-' + idx + '" width="400" height="88"></canvas>' +
        '<div class="pad-row-select">' +
          '<span class="row-select-label">GROOVE</span>' +
          '<select class="row-select" id="row-select-' + idx + '">' +
            '<option value="kick">Kick pattern</option>' +
            '<option value="snare">Snare pattern</option>' +
            '<option value="hihat">Hi-hat pattern</option>' +
            '<option value="perc">Perc pattern</option>' +
          '</select>' +
        '</div>' +
        '<div class="pad-actions">' +
          '<button class="btn-rec"      id="btn-rec-'  + idx + '">&#9679; REC</button>' +
          '<button class="btn-play-pad" id="btn-play-' + idx + '" disabled>&#9654; PLAY</button>' +
          '<button class="btn-clear"    id="btn-clear-'+ idx + '" disabled>&#10005;</button>' +
        '</div>';
      grid.appendChild(el);

      var sel = document.getElementById('row-select-' + idx);
      sel.value = PAD_ROW_DEFAULTS[idx];
      sel.addEventListener('change', function(e) { pads[idx].grooveRow = e.target.value; });

      document.getElementById('btn-rec-'   + idx).addEventListener('click', function() { toggleRecord(idx); });
      document.getElementById('btn-play-'  + idx).addEventListener('click', function() { triggerPad(idx, 1.0); });
      document.getElementById('btn-clear-' + idx).addEventListener('click', function() { clearPad(idx); });
    })(i);
  }
}

// ── Audio context ─────────────────────────────────────────────────────────────
function getAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    metroGain = audioCtx.createGain();
    metroGain.gain.value = metroMuted ? 0 : 1;
    metroGain.connect(audioCtx.destination);
  }
  if (audioCtx.state === 'suspended') audioCtx.resume();
  return audioCtx;
}

// ── Mic ───────────────────────────────────────────────────────────────────────
async function getMic() {
  if (micStream) return micStream;
  try {
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    return micStream;
  } catch(e) {
    setStatus('mic access denied');
    return null;
  }
}

// ── Metronome ─────────────────────────────────────────────────────────────────
function scheduleClick(time, accent) {
  var ctx = getAudioCtx();
  var osc = ctx.createOscillator();
  var env = ctx.createGain();
  osc.connect(env); env.connect(metroGain);
  osc.frequency.value = accent ? 1200 : 900;
  osc.type = 'sine';
  env.gain.setValueAtTime(0, time);
  env.gain.linearRampToValueAtTime(0.6, time + 0.003);
  env.gain.exponentialRampToValueAtTime(0.001, time + 0.06);
  osc.start(time); osc.stop(time + 0.08);
}

function startMetronome() {
  var ctx = getAudioCtx();
  metroBeat = 0;
  metroNextTime = ctx.currentTime + 0.05;
  function scheduler() {
    var ctx = getAudioCtx();
    while (metroNextTime < ctx.currentTime + 0.2) {
      scheduleClick(metroNextTime, metroBeat % 4 === 0);
      metroBeat++;
      metroNextTime += 60.0 / bpm;
    }
  }
  metroScheduler = setInterval(scheduler, 50);
  scheduler();
}
function stopMetronome()    { if (metroScheduler) { clearInterval(metroScheduler); metroScheduler = null; } }
function restartMetronome() { stopMetronome(); startMetronome(); }

document.getElementById('metro-btn').addEventListener('click', function() {
  metroMuted = !metroMuted;
  document.getElementById('metro-btn').classList.toggle('muted', metroMuted);
  if (metroGain) metroGain.gain.setTargetAtTime(metroMuted ? 0 : 1, getAudioCtx().currentTime, 0.02);
  setStatus(metroMuted ? 'metronome muted' : 'metronome on');
});

// ── Live visualizer ───────────────────────────────────────────────────────────
function startLiveViz(padIdx) {
  var pad = pads[padIdx];
  var canvas = document.getElementById('wave-' + padIdx);
  var ctx2 = canvas.getContext('2d');
  var analyser = pad.analyser;
  var bufLen = analyser.frequencyBinCount;
  var dataArr = new Uint8Array(bufLen);
  var W = canvas.width, H = canvas.height;
  var history = new Float32Array(W);
  var histPos = 0;

  function draw() {
    if (!pad.isRecording) return;
    pad.liveAnimFrame = requestAnimationFrame(draw);
    analyser.getByteTimeDomainData(dataArr);
    var sum = 0;
    for (var k = 0; k < bufLen; k++) { var v = (dataArr[k]/128.0)-1.0; sum += v*v; }
    var rms = Math.sqrt(sum/bufLen);
    history[histPos % W] = rms; histPos++;
    ctx2.clearRect(0,0,W,H);
    var mid = H/2;
    for (var x = 0; x < W; x++) {
      var hi = history[(histPos-W+x+W*4) % W];
      var amp = Math.min(hi * H * 3.5, mid);
      var a = 0.25 + (x/W)*0.75;
      var r = Math.min(255, Math.round(232 + rms*300));
      var g = Math.max(0, Math.round(255 - rms*700));
      ctx2.fillStyle = 'rgba('+r+','+g+',58,'+a+')';
      ctx2.fillRect(x, mid-amp, 1, Math.max(amp*2, 1));
    }
    ctx2.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx2.lineWidth = 1;
    ctx2.beginPath(); ctx2.moveTo(0,mid); ctx2.lineTo(W,mid); ctx2.stroke();
  }
  draw();
}

function stopLiveViz(padIdx) {
  var pad = pads[padIdx];
  if (pad.liveAnimFrame) { cancelAnimationFrame(pad.liveAnimFrame); pad.liveAnimFrame = null; }
  if (pad.analyserSource) { try { pad.analyserSource.disconnect(); } catch(e) {} pad.analyserSource = null; }
  pad.analyser = null;
}

// ── Recording — VAD-triggered auto-stop ───────────────────────────────────────
// Flow: REC pressed → open mic → calibrate noise floor for 300ms
//       → wait for signal above threshold → record until signal drops away for 120ms → stop
// No fixed time limit. Trims silence from front after decode.

var VAD_POLL_MS      = 20;
var VAD_CALIBRATE_MS = 300;
var VAD_TAIL_MS      = 120;
var VAD_MAX_MS       = 8000;

async function toggleRecord(i) {
  var pad = pads[i];
  if (pad.isRecording) { stopRecord(i); return; }
  if (activeRecordingPad !== null) stopRecord(activeRecordingPad);
  await startRecord(i);
}

async function startRecord(i) {
  var pad = pads[i];
  pad.isRecording = true;
  updatePadUI(i);
  setStatus('requesting mic...');
  getAudioCtx();
  if (!metroScheduler) startMetronome();

  var stream = await getMic();
  if (!stream) { pad.isRecording = false; updatePadUI(i); return; }

  pad.pcmChunks = [];  // collect raw Float32 samples
  activeRecordingPad = i;

  var ctx = getAudioCtx();
  var source = ctx.createMediaStreamSource(stream);

  // Analyser for VAD + visualiser
  var analyser = ctx.createAnalyser();
  analyser.fftSize = 1024;
  source.connect(analyser);
  pad.analyser = analyser;
  pad.analyserSource = source;
  startLiveViz(i);

  // ScriptProcessorNode to collect raw PCM — works on iOS Safari where MediaRecorder does not
  var bufSize = 4096;
  var recorder = ctx.createScriptProcessor(bufSize, 1, 1);
  recorder.onaudioprocess = function(e) {
    if (!pad.isRecording) return;
    // copy samples out (the buffer is reused so we must slice)
    var samples = e.inputBuffer.getChannelData(0);
    pad.pcmChunks.push(new Float32Array(samples));
  };
  source.connect(recorder);
  recorder.connect(ctx.destination); // must be connected to run on iOS
  // Mute the output immediately so we don't hear ourselves
  var muteGain = ctx.createGain();
  muteGain.gain.value = 0;
  recorder.disconnect(ctx.destination);
  recorder.connect(muteGain);
  muteGain.connect(ctx.destination);

  pad.scriptRecorder = recorder;
  pad.muteGain = muteGain;

  updatePadUI(i);
  setStatus('calibrating mic... (pad ' + (i+1) + ')');

  // VAD state machine — same logic, driven by analyser RMS
  var pollCount = 0;
  var calibratePollsNeeded = Math.round(VAD_CALIBRATE_MS / VAD_POLL_MS);
  var tailPollsNeeded      = Math.round(VAD_TAIL_MS / VAD_POLL_MS);
  var maxPollsAllowed      = Math.round(VAD_MAX_MS / VAD_POLL_MS);
  var floorAccum = 0, floorCount2 = 0;
  var threshold = 0.015;
  var tailCount = 0;
  var phase = 'calibrate';

  pad.vadInterval = setInterval(function() {
    if (!pad.isRecording || !pad.analyser) { stopVAD(i); return; }
    pollCount++;

    var bufLen = pad.analyser.frequencyBinCount;
    var data = new Uint8Array(bufLen);
    pad.analyser.getByteTimeDomainData(data);
    var sum = 0;
    for (var k = 0; k < bufLen; k++) { var v2 = (data[k]/128.0)-1.0; sum += v2*v2; }
    var rms = Math.sqrt(sum/bufLen);

    if (phase === 'calibrate') {
      floorAccum += rms; floorCount2++;
      if (pollCount >= calibratePollsNeeded) {
        threshold = Math.max((floorAccum/floorCount2) * 8, 0.012);
        phase = 'waiting';
        setStatus('ready — make your sound (pad ' + (i+1) + ')');
      }
    } else if (phase === 'waiting') {
      if (rms > threshold) { phase = 'active'; tailCount = 0; setStatus('capturing... (pad ' + (i+1) + ')'); }
    } else if (phase === 'active') {
      if (rms < threshold) {
        tailCount++;
        if (tailCount >= tailPollsNeeded) { stopVAD(i); if (pad.isRecording) stopRecord(i); return; }
      } else { tailCount = 0; }
    }
    if (pollCount >= maxPollsAllowed) { stopVAD(i); if (pad.isRecording) stopRecord(i); }
  }, VAD_POLL_MS);
}

function stopVAD(i) {
  if (pads[i].vadInterval) { clearInterval(pads[i].vadInterval); pads[i].vadInterval = null; }
}

function stopRecord(i) {
  var pad = pads[i];
  if (!pad.isRecording) return;
  stopVAD(i);
  pad.isRecording = false;
  activeRecordingPad = null;
  stopLiveViz(i);

  // Disconnect ScriptProcessor
  if (pad.scriptRecorder) {
    try { pad.scriptRecorder.disconnect(); } catch(e) {}
    pad.scriptRecorder = null;
  }
  if (pad.muteGain) {
    try { pad.muteGain.disconnect(); } catch(e) {}
    pad.muteGain = null;
  }

  setStatus('processing...');
  updatePadUI(i);
  finalizeRecording(i);
}

// ── Trim leading silence (adaptive) ──────────────────────────────────────────
function trimSilence(buffer) {
  var data = buffer.getChannelData(0);
  var sr = buffer.sampleRate;

  // Scan the whole buffer to find the absolute peak — tells us if there's even signal
  var peak = 0;
  for (var p = 0; p < data.length; p++) { var ap = Math.abs(data[p]); if (ap > peak) peak = ap; }

  // If peak is basically nothing, nothing to trim
  if (peak < 0.001) {
    console.log('[trim] buffer is near-silent, skipping. peak=', peak);
    return buffer;
  }

  // Use a threshold that is a fixed fraction of the peak — robust regardless of mic level
  // Anything below 5% of peak is treated as silence
  var threshold = peak * 0.05;

  console.log('[trim] duration=' + buffer.duration.toFixed(3) + 's  peak=' + peak.toFixed(4) + '  threshold=' + threshold.toFixed(4));

  var winSize = Math.max(Math.floor(sr * 0.002), 1);
  var startSample = -1;
  for (var n = 0; n < data.length - winSize; n += winSize) {
    var ws = 0;
    for (var w = 0; w < winSize; w++) ws += data[n+w]*data[n+w];
    if (Math.sqrt(ws/winSize) > threshold) { startSample = Math.max(0, n - winSize); break; }
  }

  console.log('[trim] startSample=' + startSample + ' (' + (startSample/sr*1000).toFixed(1) + 'ms)');

  if (startSample <= 0) return buffer;

  var ctx = getAudioCtx();
  var nc = buffer.numberOfChannels;
  var newLen = buffer.length - startSample;
  if (newLen <= 0) return buffer;
  var out = ctx.createBuffer(nc, newLen, sr);
  for (var c = 0; c < nc; c++) {
    var src = buffer.getChannelData(c), dst = out.getChannelData(c);
    for (var s = 0; s < newLen; s++) dst[s] = src[startSample+s];
  }
  console.log('[trim] trimmed ' + (startSample/sr*1000).toFixed(1) + 'ms of silence. new duration=' + out.duration.toFixed(3) + 's');
  return out;
}

function finalizeRecording(i) {
  var pad = pads[i];
  try {
    var chunks = pad.pcmChunks;
    if (!chunks || chunks.length === 0) { setStatus('no audio captured — try again'); updatePadUI(i); return; }

    // Concatenate all PCM chunks into one Float32Array
    var totalLen = 0;
    for (var ci = 0; ci < chunks.length; ci++) totalLen += chunks[ci].length;
    var combined = new Float32Array(totalLen);
    var offset = 0;
    for (var ci2 = 0; ci2 < chunks.length; ci2++) {
      combined.set(chunks[ci2], offset);
      offset += chunks[ci2].length;
    }

    // Build an AudioBuffer from the raw PCM
    var ctx = getAudioCtx();
    var sr = ctx.sampleRate;
    var decoded = ctx.createBuffer(1, combined.length, sr);
    decoded.getChannelData(0).set(combined);

    pad.pcmChunks = [];
    pad.buffer = trimSilence(decoded);
    drawWaveform(i);
    updatePadUI(i);
    setStatus('pad ' + (i+1) + ' ready (' + pad.buffer.duration.toFixed(3) + 's)');
  } catch(e) {
    console.error('finalizeRecording error:', e);
    setStatus('processing failed — try again');
    updatePadUI(i);
  }
}

// ── Playback with velocity-scaled gain ───────────────────────────────────────
function triggerPad(i, velocity) {
  var pad = pads[i];
  if (!pad.buffer || velocity <= 0) return;
  var ctx = getAudioCtx();
  var src = ctx.createBufferSource();
  src.buffer = pad.buffer;
  var gain = ctx.createGain();
  gain.gain.value = Math.min(velocity, 1.0);
  src.connect(gain); gain.connect(ctx.destination);
  src.start();
  var el = document.getElementById('pad-' + i);
  el.classList.add('flashing');
  if (velocity > 0.7) el.classList.add('flash-accent');
  setTimeout(function() { el.classList.remove('flashing','flash-accent'); }, velocity > 0.7 ? 110 : 55);
}

function clearPad(i) {
  stopVAD(i);
  pads[i].buffer = null;
  clearWaveform(i);
  updatePadUI(i);
  setStatus('pad ' + (i+1) + ' cleared');
}

// ── Sequencer — 16th-note steps, groove drives velocity ──────────────────────
function stepMs() { return (60 / bpm / 4) * 1000; }

function startSequencer() {
  currentStep = -1;
  beatInterval = setInterval(tick, stepMs());
  tick();
}
function stopSequencer() {
  clearInterval(beatInterval); beatInterval = null;
  document.querySelectorAll('.beat-dot').forEach(function(d) { d.classList.remove('active'); });
  currentStep = -1;
  clearGrooveHighlight();
}

function tick() {
  currentStep = (currentStep + 1) % 16;
  // Beat dots on quarter notes
  if (currentStep % 4 === 0) {
    var qb = currentStep / 4;
    document.querySelectorAll('.beat-dot').forEach(function(d, i) { d.classList.toggle('active', i === qb); });
  }

  var grooveIdx = parseInt(document.getElementById('groove-select').value) || 0;
  var groove = GROOVES[grooveIdx];

  pads.forEach(function(pad, pi) {
    if (!pad.buffer) return;
    var rowData = getGrooveRow(groove, pad.grooveRow);
    if (!rowData) return;
    var val = rowData[currentStep];
    var vel = VELOCITY[val] || 0;
    if (vel > 0) triggerPad(pi, vel);
  });

  updateGrooveHighlight(currentStep);
}

// ── Transport ─────────────────────────────────────────────────────────────────
document.getElementById('play-btn').addEventListener('click', function() {
  getAudioCtx();
  if (!metroScheduler) startMetronome();
  isPlaying = !isPlaying;
  var btn = document.getElementById('play-btn');
  if (isPlaying) {
    btn.innerHTML = '&#9632; STOP'; btn.classList.add('playing');
    startSequencer();
  } else {
    btn.innerHTML = '&#9654; PLAY'; btn.classList.remove('playing');
    stopSequencer(); setStatus('stopped');
  }
});

document.getElementById('bpm-up').addEventListener('click', function()   { changeBpm(5);  });
document.getElementById('bpm-down').addEventListener('click', function() { changeBpm(-5); });

function changeBpm(delta) {
  bpm = Math.max(40, Math.min(240, bpm + delta));
  document.getElementById('bpm-display').textContent = bpm;
  if (isPlaying)       { stopSequencer(); startSequencer(); }
  if (metroScheduler)  restartMetronome();
}

// ── Waveform ──────────────────────────────────────────────────────────────────
function drawWaveform(i) {
  var pad = pads[i];
  if (!pad.buffer) return;
  var canvas = document.getElementById('wave-' + i);
  var ctx2 = canvas.getContext('2d');
  var data = pad.buffer.getChannelData(0);
  var W = canvas.width, H = canvas.height;
  ctx2.clearRect(0,0,W,H);
  ctx2.strokeStyle = '#e8ff3a'; ctx2.lineWidth = 1.5; ctx2.beginPath();
  var step = Math.ceil(data.length / W);
  for (var x = 0; x < W; x++) {
    var mn=1, mx=-1;
    for (var j=0; j<step; j++) { var s=data[x*step+j]||0; if(s<mn)mn=s; if(s>mx)mx=s; }
    var y1=(1-(mx+1)/2)*H, y2=(1-(mn+1)/2)*H;
    if (x===0) ctx2.moveTo(x,y1); else ctx2.lineTo(x,y1);
    ctx2.lineTo(x,y2);
  }
  ctx2.stroke();
}
function clearWaveform(i) { document.getElementById('wave-'+i).getContext('2d').clearRect(0,0,400,88); }

// ── Pad UI state ──────────────────────────────────────────────────────────────
function updatePadUI(i) {
  var pad = pads[i];
  var el       = document.getElementById('pad-'       + i);
  var status   = document.getElementById('pad-status-'+ i);
  var recBtn   = document.getElementById('btn-rec-'   + i);
  var playBtn  = document.getElementById('btn-play-'  + i);
  var clearBtn = document.getElementById('btn-clear-' + i);

  el.classList.remove('recording','has-sample');
  if (pad.isRecording) el.classList.add('recording');
  else if (pad.buffer) el.classList.add('has-sample');

  if (pad.isRecording) {
    status.textContent = 'listening...';
    recBtn.innerHTML = '&#9632; STOP';
    recBtn.style.cssText = 'background:#ff3a3a;color:#fff;border-color:#ff3a3a';
  } else if (pad.buffer) {
    status.textContent = pad.buffer.duration.toFixed(3) + 's';
    recBtn.innerHTML = '&#9679; REC';
    recBtn.style.cssText = '';
  } else {
    status.textContent = 'empty';
    recBtn.innerHTML = '&#9679; REC';
    recBtn.style.cssText = '';
  }
  playBtn.disabled  = !pad.buffer;
  clearBtn.disabled = !pad.buffer;
}

function setStatus(msg) { statusBar.textContent = msg; }

// ── Groove data ───────────────────────────────────────────────────────────────
// 16-step patterns. 0=silent, 1=soft hit (42% vel), 2=accent (100% vel)
// perc = hihat pattern shifted right by 2 steps (half a beat later)
function getGrooveRow(groove, row) {
  if (row !== 'perc') return groove[row];
  var h = groove['hihat'];
  var shifted = new Array(16);
  for (var si = 0; si < 16; si++) shifted[si] = h[(si + 14) % 16]; // shift right by 2 = shift left by 14
  return shifted;
}

var GROOVES = [
  { name:"Basic Rock",
    desc:"Kick on 1&3, snare backbeat on 2&4, steady 8th hi-hats. The foundation of rock.",
    kick: [2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    snare:[0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0],
    hihat:[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0] },
  { name:"Funk Groove",
    desc:"Heavy accent on beat 1 ('the one'). Kick/snare syncopate. Hi-hats open/closed.",
    kick: [2,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0],
    snare:[0,0,0,0,2,0,0,1,0,0,0,0,2,0,1,0],
    hihat:[2,1,1,1,1,2,1,1,2,1,1,1,1,2,1,1] },
  { name:"Classic Hip-Hop",
    desc:"Laid-back kick, syncopated offbeats. Snare on 2&4. Sparse hi-hats.",
    kick: [2,0,0,0,0,0,1,0,2,0,0,0,0,1,0,0],
    snare:[0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0],
    hihat:[1,0,1,0,0,1,0,0,1,0,1,0,0,1,0,1] },
  { name:"Trap",
    desc:"Booming kick on 1, snare on 3, rolling 16th hi-hats accent upbeats.",
    kick: [2,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0],
    snare:[0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    hihat:[1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1] },
  { name:"Four-on-the-Floor",
    desc:"Kick every quarter note, snare on 2&4, 16th hi-hats accent offbeats.",
    kick: [2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0],
    snare:[0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0],
    hihat:[1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1] },
  { name:"Disco",
    desc:"Four-on-floor kick, snare on 2&4, open hi-hat on the 'and' of every beat.",
    kick: [2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0],
    snare:[0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0],
    hihat:[1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0] },
  { name:"Blues Shuffle",
    desc:"Triplet swing. Accent on the 'and' of each beat.",
    kick: [2,0,1,0,0,1,0,0,2,0,1,0,0,1,0,0],
    snare:[0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0],
    hihat:[1,0,2,0,1,0,2,0,1,0,2,0,1,0,2,0] },
  { name:"Jazz Swing",
    desc:"Ride carries the swing triplet. Kick sparse. Snare soft on 2&4.",
    kick: [2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
    snare:[0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
    hihat:[2,0,1,0,2,0,1,0,2,0,1,0,2,0,1,0] },
  { name:"Reggae",
    desc:"Kick soft on 1, snare only on beat 3. Hi-hats on offbeats — the 'skank'.",
    kick: [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    snare:[0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    hihat:[0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0] },
  { name:"Bossa Nova",
    desc:"3+3+2 clave feel. Snare is subtle. Hi-hat flows smoothly.",
    kick: [2,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0],
    snare:[0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0],
    hihat:[1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1] },
  { name:"Latin Samba",
    desc:"Lively syncopated kick, ghost snare notes. Hi-hats on every 16th.",
    kick: [2,0,1,0,0,1,0,1,2,0,1,0,0,1,0,0],
    snare:[0,1,0,0,2,0,1,0,0,1,0,0,2,0,1,0],
    hihat:[2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,1] },
  { name:"Breakbeat",
    desc:"Snare on unexpected 16ths. Kick syncopates heavily. Forward momentum.",
    kick: [2,0,0,0,0,0,1,0,0,0,2,0,0,1,0,0],
    snare:[0,0,0,0,2,0,0,1,0,0,0,0,1,1,0,0],
    hihat:[2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1] },
  { name:"Downtempo / Trip-Hop",
    desc:"Slow, heavy. Kick on 1 + 'and' of 2. Snare on 3. Sparse hi-hats.",
    kick: [2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0],
    snare:[0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    hihat:[1,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0] },
  { name:"Half-Time Metal",
    desc:"Snare only on beat 3. Double kick on 1. Relentless hi-hats.",
    kick: [2,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0],
    snare:[0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0],
    hihat:[2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2] },
  { name:"2-Step / UK Garage",
    desc:"Kick avoids 2&4. Clap on the 'and' of 2 and 4. Skippy hi-hats.",
    kick: [2,0,0,0,0,1,0,0,2,0,0,1,0,0,0,0],
    snare:[0,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0],
    hihat:[1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1] },
  { name:"Afrobeat",
    desc:"Clave-like hi-hat pattern. Kick and snare lock into polyrhythmic cycle.",
    kick: [2,0,0,1,0,0,1,0,0,0,2,0,0,1,0,0],
    snare:[0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0],
    hihat:[2,0,1,0,1,0,2,0,1,0,1,0,2,0,1,0] }
];

// ── Groove guide UI ───────────────────────────────────────────────────────────
function buildGrooveSelector() {
  var sel = document.getElementById('groove-select');
  GROOVES.forEach(function(g, i) {
    var opt = document.createElement('option');
    opt.value = i; opt.textContent = g.name;
    sel.appendChild(opt);
  });
  sel.addEventListener('change', function() { renderGroove(parseInt(sel.value)); });

  var labelsEl = document.getElementById('groove-beat-labels');
  var names = ['1','e','+','a','2','e','+','a','3','e','+','a','4','e','+','a'];
  for (var b = 0; b < 16; b++) {
    var lbl = document.createElement('div');
    lbl.className = 'groove-beat-label';
    lbl.textContent = names[b];
    if (b % 4 === 0) lbl.style.color = 'var(--accent)';
    labelsEl.appendChild(lbl);
  }
  renderGroove(0);
}

function renderGroove(idx) {
  var g = GROOVES[idx];
  document.getElementById('groove-desc').textContent = g.desc;
  var gridEl = document.getElementById('groove-grid');
  gridEl.innerHTML = '';
  [['KICK',getGrooveRow(g,'kick')],['SNARE',getGrooveRow(g,'snare')],['HIHAT',getGrooveRow(g,'hihat')],['PERC',getGrooveRow(g,'perc')]].forEach(function(pair) {
    var rowEl = document.createElement('div'); rowEl.className = 'groove-row-el';
    var lbl = document.createElement('div'); lbl.className = 'groove-row-label'; lbl.textContent = pair[0];
    var stepsEl = document.createElement('div'); stepsEl.className = 'groove-steps';
    pair[1].forEach(function(val, si) {
      var s = document.createElement('div'); s.className = 'groove-step';
      if (si > 0 && si % 4 === 0) s.classList.add('beat-gap');
      if (val === 1) s.classList.add('on');
      if (val === 2) s.classList.add('accent');
      stepsEl.appendChild(s);
    });
    rowEl.appendChild(lbl); rowEl.appendChild(stepsEl);
    gridEl.appendChild(rowEl);
  });
}

function updateGrooveHighlight(step) {
  document.querySelectorAll('.groove-steps').forEach(function(stepsEl) {
    var children = stepsEl.querySelectorAll('.groove-step');
    children.forEach(function(el, i) { el.classList.toggle('now', i === step); });
  });
}

function clearGrooveHighlight() {
  document.querySelectorAll('.groove-step').forEach(function(el) { el.classList.remove('now'); });
}

document.getElementById('groove-header').addEventListener('click', function() {
  document.getElementById('groove-panel').classList.toggle('open');
});

// ── Keyboard ──────────────────────────────────────────────────────────────────
document.addEventListener('keydown', function(e) {
  var key = e.key.toUpperCase();
  var i = PAD_KEYS.indexOf(key);
  if (i !== -1) triggerPad(i, 1.0);
  if (key === ' ') { e.preventDefault(); document.getElementById('play-btn').click(); }
  if (key === 'M') document.getElementById('metro-btn').click();
});

// ── Init ──────────────────────────────────────────────────────────────────────
buildUI();
buildGrooveSelector();

// Pre-warm mic permission on first user gesture (click anywhere)
// so it's already granted before REC is pressed
var micPermissionGranted = false;
function prewarmMic() {
  if (micPermissionGranted) return;
  navigator.mediaDevices.getUserMedia({ audio: true, video: false })
    .then(function(stream) {
      micStream = stream;
      micPermissionGranted = true;
      setStatus('mic ready  |  press REC on a pad when ready');
    })
    .catch(function() {
      setStatus('mic access denied — check browser permissions');
    });
}
document.addEventListener('click', function() { prewarmMic(); }, { once: true });

setStatus('click anywhere to enable mic, then press REC  |  M = mute click');
</script>
</body>
</html>
